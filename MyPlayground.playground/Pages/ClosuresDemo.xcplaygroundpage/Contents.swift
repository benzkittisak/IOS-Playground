import UIKit
/*
 closure คือ ฟังก์ชันที่มันไม่มีชื่อแหละ
 วิธีการเปลี่ยน function ธรรมดาให้เป็น closure ก็คือ
 1. ลบน้อง func กับชื่อฟังก์ชันออกให้หมดเลย
 2. ย้ายน้อง { ที่อยู่ข้างหลัง () มาไว้ข้างหน้าแทน
 3. ต่อท้ายงาม ๆ ด้วยคำว่า in หลัง type ของ func
 */

func calculator (n1:Int , n2:Int) -> Int {
    return n1 + n2
}

// ก็เรื่องปกติแหละนะที่ฟังก์ชันจะส่งค่าเข้าไปแล้วออกมาเป็นค่าอีกค่า แต่ก็เรื่องปกติเหมือนกันที่ฟังก์ชันจะรับฟังก์ชันเข้าไปแล้วออกมาเป็นอีกฟังก์ชันนุงเช่น
func add (no1:Int , no2:Int) -> Int {
    return no1 + no2
}

calculator(n1:2 , n2: 3)

// ทีนี้เราจะมาแก้ตัวฟังก์ชัน calculator ใหม่
// หึ่มก็เข้าใจยากหน่อยแหละนะแต่ก็อารมณ์ประมาณว่ารับตัวเลขมา 2 ตัว n1 n2 นี่แหละ แล้วก็รับฟังก์ชันของการดำเนินการมาด้วยว่าจะเอาเลข 2 ตัวนั้นไปทำแมวอะไรหว่า
// แต่แทนที่เราจะทำแมวในฟังก์ชันคำนวณเลขเพียว ๆ เลย เราก็ส่งฟังก์ชันการคำนวณไปให้มันเลยละกัน
// มันจะสะดวกแหละเนอะถ้าเกิดว่าเราต้องการที่จะลบเลข บวกเลข อะไรไม่ต้องมาเขียน if อะไรให้ยุ่งยาก
func calculator2(n1:Int , n2:Int , operation:(Int , Int) -> Int) -> Int {
    return operation(n1 , n2)
}

// เรียกใช้้แบบนี้ยังไงลา
calculator2(n1: 2, n2: 3 , operation: add)

// เรามาลองใช้ closure กับตัวฟังก์ชัน คูณดีฟ่า แต่ก่อนจะทำมาดูว่าปกติเราเขียนยังไงก่อน
// ยังงี้ไงล้าา
func multiply (no1:Int , no2:Int) -> Int {
    return no1 * no2
}
// แล้วจะเปลี่ยนเป็น closure ยังไง ก็ยังงี้ไงล้า ขอเม้นไว้ก่อนโค้ดมันเออเร่อน่ะ
// จะเห็นว่ามันจะต่างกันเยอะมาก
/*
{ (no1:Int , no2:Int) -> Int in
    return no1 * no2
}*/

// แล้วเราจะเอา closure ไปใช้กับโค้ด calculator2 ของเราได้ยังไง มาดูกันเลอ
// ก็ย้ายทั้งหมดจาก 40 - 42 มาไว้ใน operation ไปเลย
calculator2(n1: 2 , n2: 3 , operation: { (no1:Int , no2:Int) -> Int in
    return no1 * no2
})

// หรือจะใช้แบบที่สุดโต่งไปหน่อยก็ได้
// $0 อันนี้หมายถึงพารามิเตอร์ตัวที่ 1 อะนะ
let result = calculator2(n1: 2, n2: 3, operation: {$0 * $1})
print(result)

// รึแบบนี้ก้ได้เอา closure ไปต่อท้ายฟังก์ชัน
let result2 = calculator2(n1: 2, n2: 3) {$0 * $1}
print(result2)
